1. Pair Structuring Logic
This part of the code organizes all available trading pairs into triangular combinations. 
For example, BTC can be traded for USD, USD for ETH, and ETH back to BTC. The bot structures the loop and prepares it for analysis.

# Make a get request
def get_coin_tickers(url):
    req = requests.get(url)
    json_resp = json.loads(req.text)
    return json_resp


# Loop through each objects and find the trade able pairs
def collect_tradeables(json_obj, ending_currency):
    coin_list = []
    for pair_name, pair_info in json_obj["result"].items():
        if pair_info["wsname"] == pair_name and pair_info["altname"].endswith(ending_currency):
            coin_list.append(pair_info["wsname"])
    return coin_list

# Structure Arbitrage Pairs
def structure_triangular_pairs(coin_list):
    # Declare Variables
    triangular_pairs_list = []
    remove_duplicates_list = []
    pairs_list = coin_list[0:]

# Example:
symbols = ["BTC/USD", "USD/ETH", "ETH/BTC"]
pairs = find_triangular_pairs(symbols)
print("Possible Triangular Pairs:", pairs)

2. Price Checking Logic
After forming trading loops, the bot checks current prices from the exchange APIs to see if converting from BTC → USD → ETH → BTC 
will result in more BTC than I started with. If the numbers line up, that’s a profit!
  
# Structure Prices
def get_price_for_t_pair(t_pair, prices_json):
    # Extract Pair Info
    pair_a = t_pair["pair_a"]
    pair_b = t_pair["pair_b"]
    pair_c = t_pair["pair_c"]

    # Extract Price Information for Given Pairs
    pair_a_ask = float(prices_json[pair_a]["lowestAsk"])
    pair_a_bid = float(prices_json[pair_a]["highestBid"])
    pair_b_ask = float(prices_json[pair_b]["lowestAsk"])
    pair_b_bid = float(prices_json[pair_b]["highestBid"])
    pair_c_ask = float(prices_json[pair_c]["lowestAsk"])
    pair_c_bid = float(prices_json[pair_c]["highestBid"])

    # Output Dictionary
    return {
        "pair_a_ask": pair_a_ask,
        "pair_a_bid": pair_a_bid,
        "pair_b_ask": pair_b_ask,
        "pair_b_bid": pair_b_bid,
        "pair_c_ask": pair_c_ask,
        "pair_c_bid": pair_c_bid
    }
  
3. Profit Condition Check
The bot calculates a profit greater than zero after going through the loop (BTC → USD → ETH → BTC). 
This is incredibly important condition, I'm teaching the bot to recognize if the arbitrage opportunity is worth executing.
# Determining Triangular Match
   if counts_c_base == 2 and counts_c_quote == 2 and c_base != c_quote:
      combined = pair_a + "," + pair_b + "," + pair_c
      unique_item = ''.join(sorted(combine_all))

   if unique_item not in remove_duplicates_list:
      match_dict = {
       "a_base": a_base,
       "b_base": b_base,
       "c_base": c_base,
       "a_quote": a_quote,
       "b_quote": b_quote,
       "c_quote": c_quote,
       "pair_a": pair_a,
       "pair_b": pair_b,
       "pair_c": pair_c,
       "combined": combined
     }
   triangular_pairs_list.append(match_dict)
   remove_duplicates_list.append(unique_item)

    # Return result
    return triangular_pairs_list

